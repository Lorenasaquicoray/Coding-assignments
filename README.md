# Coding-assignments data structure
Assignment 1 – Insertion Sort Program
Implements the insertion sort algorithm in Python, accepting 8 integers from the user. As each integer is entered, it is inserted into the correct position within a sorted array, and the updated sorted list is displayed after each entry.

Assignment 2 – Algorithm Complexity Analysis
Analyzes and implements several code fragments to determine their Big-O runtime complexities. The program measures actual execution times for different input sizes, compares them with theoretical complexity analysis, and discusses efficiency.

Tree Assignment
Implements a tree data structure with nodes containing value, parent, leftChild, and rightChild properties. Includes inorder, preorder, and postorder traversal methods, a function to verify if a tree is a binary search tree (BST), and a method to find the successor of a given node. Tested with both valid and invalid BSTs.

Red-Black Tree Assignment
Builds a Red-Black Tree implementation with methods for insertion, deletion, rotations, and tree fix-up operations. Inserts a set of given values, compares results to an expected structure, and explains differences.

Hash Assignment
Implements several hashing techniques, including separate chaining, linear probing, quadratic probing, and double hashing. Simulates insertions from a random sequence to measure collision counts, analyzes why linear probing has high collision rates, and implements an improvement to reduce them.

Heap Assignment – Min Heap & d-Heap Analysis
Implements a minimum heap data structure in two ways:

Incremental Insertion — elements are inserted into the heap one at a time.

Heapify in Linear Time — all elements are added at once to build the heap.

The program tests both methods with three different input scenarios: ascending sorted input, descending sorted input, and randomized input. It compares run times for all six approaches and includes an analysis of parent-child index relationships in a d-heap stored as an array, with examples for 0-based and 1-based indexing.

Greedy & Divide and Conquer Assignment
Solves two algorithmic problems using both brute-force and optimized approaches:

Activity Selection — implemented with brute force and a greedy algorithm.

Maximum Subarray Problem — implemented with brute force and divide-and-conquer.

Execution times are compared, and performance is analyzed.

Graph Assignment – Ford-Fulkerson
Implements the Ford-Fulkerson method to find maximum flow in a given graph. Also applies the algorithm to a larger custom graph and includes extra credit analysis of conditions under which the method fails, along with an implemented fix.

Dynamic Programming – 0/1 Knapsack
Solves the 0/1 Knapsack problem using dynamic programming for two cases:

Knapsack capacity = 11

Knapsack capacity = 10,000

Outputs maximum value and the items chosen in a readable format.

Complexity Class Assignment (NP-Complete Problem)
Selects an NP-complete problem, implements a solution programmatically, and demonstrates functionality through unit testing. Reduces the chosen problem to another NP-complete problem, with a clear step-by-step explanation in presentation format.

Complexity Class Assignment Two
Chooses an NP-complete or NP-hard problem and solves it using both brute-force and a faster algorithm. Increases input size incrementally, measures execution times, and plots results to demonstrate performance differences.

